## JAVA并发

### OK:

1. 创建和执行线程start(),run()
2. 进程线程区别。

### NOT OK -> OK

1. t.join(): 等待t线程执行完再执行其他线程。（没有join就是并行线程。）

2. ##### interrupt():

   1) t.interrupt() 母线程向t线程发送中断请求。

   2) <font color=red>t中可以写逻辑代码，捕获到中断请求并中断t线程。如果t代码没有写中断逻辑，如break，则t还是不好中断。</font>

   3) t线程中如果有等待s线性，那么即使中断了t线程，也不会中断s线程

3. `volatile`关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。原因：在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！

4. 守护线程（Daemon Thread）：目的是无限循环某个线程。当所有非守护线程执行完毕后，JVM都会自动退出。

5. ##### 线程同步（锁）：

   1）使用`synchronized`解决了多线程同步访问共享变量的正确性问题。但是，它的缺点是带来了性能下降。

   2）JVM规范定义了几种原子操作：

   - 基本类型（`long`和`double`除外）赋值，例如：`int n = m`；
   - 引用类型赋值，例如：`List list = anotherList`。

   3）单条原子操作的语句不需要同步。

6. 如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe）

7. ##### 死锁：

   1）第一个线程已有A锁，但A锁未释放，想要获得B锁。同时第二个线程已有B锁，但B锁未释放，想要获得A锁。各自试图获取对方手里的锁，造成双方无限等待，这就是死锁。

   2）死锁无解，只能强制退出JVM

   3）避免死锁方法：线程获取锁的顺序要一致。即严格按照先获取`lockA`，再获取`lockB`的顺序。

### STILL NOT OK：

1. 线程同步方法。
2. 创建线程的4种方法。
3. 线程的生命周期。